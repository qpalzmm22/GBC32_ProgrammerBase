# 클로저 프로그래밍 언어
Clojure는 다중 스레드 프로그래밍을 위한 효율적이고 강력한 인프라와 스크립팅 언어의 접근 가능성 및 대화형 개발을 결합한 동적 범용 프로그래밍 언어입니다. Clojure는 컴파일된 언어이지만 완전히 동적으로 유지됩니다. Clojure에서 지원하는 모든 기능은 런타임에 지원됩니다. Clojure는 선택적 유형 힌트 및 유형 유추와 함께 Java 프레임워크에 대한 쉬운 액세스를 제공하여 Java 호출이 반사를 피할 수 있도록 합니다.

Clojure는 Lisp의 방언이며 Lisp와 데이터로서의 코드 철학 및 강력한 매크로 시스템을 공유합니다. Clojure는 주로 함수형 프로그래밍 언어이며 불변하고 지속적인 데이터 구조의 풍부한 세트를 제공합니다. 변경 가능한 상태가 필요할 때 Clojure는 깨끗하고 정확한 다중 스레드 설계를 보장하는 소프트웨어 트랜잭션 메모리 시스템과 반응 에이전트 시스템을 제공합니다.

Clojure의 우아하고 강력하며 실용적이고 재미있게 조합된 기능을 만나보시기 바랍니다.

출처 : https://clojure.org/

# LISP에 관하여

## LISP

LISP은 인공지능 언어 중의 하나로 오늘까지 널리 사용되고 있는 언어중 FORTRAN 다음으로 오래된 언어이다.

수학적 재귀함수 이론에 기반을 두고 만들어진 함수형 언어(Functional Language)이며 알고리즘을 어떻게 수행 하여야 하는지 기술하는 절차적 언어(Procedural Language)의 특성도 가지고 있다.



-LISP의 장점

재귀적(Recursive) 프로그래밍 작성이 용이하다.
자동적으로 Garbage Collection을 수행하여 메모리 사용 효율이 높인다.
프로그램과 데이터의 표현이 동일하다. 이는 다음과 같은 작업을 쉽게 할 수 있게 한다.
+ 하나의 프로그램이 다른 프로그램을 검사할 수 있다.
+ 프로그램의 수행으로 새로운 프로그램을 생성할 수 있다.
+ 프로그램이 수행되면서 프로그램 내용을 변경할 수 있다. -> 학습이 가능하다
+ 하나의 프로그램을 다른 프로그램의 데이터로 사용할 수 있다.
인터프리터와 컴파일러를 모두 사용할 수 있어 상호작용이 편한 프로그램 개발 환경이 제공된다.

이러한 장점때문에 LISP은 주로 AI의 자연어처리, 추론, 전문가 시스템, 자동 프로그래밍, 로보틱스, 컴퓨터 시각, 음성인식 등에 사용된다.

LISP에서 사용하는 기본적인 데이터에는 Symbol, Number, S-Expression이 있다. 각각 심볼, 숫자, 문장이다. S-Expression은 소괄호로 만들어진 문장으로 Symbolic Expression의 줄임이다.


출처: https://man-about-town.tistory.com/13 [YongWook's Notes]



# 클로저(Clojure)에 빠져들기

## Clojure

학창 시절 선망의 언어 리스프(Lisp)와 인제야 조금 친해질 것 같다. 
나름의 계기로 리스프 계열(family)의 언어 중에 클로저(Clojure)를 골라서 기웃기웃 살펴보며 놀고 있다. 아직은 별다른 프로젝트 없이 책이나 문서를 읽고 있는데, 인제 슬슬 염두해 두었던 프로젝트를 직접 개발해보면서 파고들어야할 단계인 것 같다.

## 클로저의 걸림돌

클로저를 비롯한 리스프 언어가 강력한 이유를 종종 접해 들을 수 있었지만, 사소한 문제(?)들로 고민하며 쉽게 도전할 수 없었다. 실제로는 사소하지만, 그것이 어쩌면 굵직한 심리적 장애물로 작용했던 문제들일지도 모르겠다. 무언가 불투명할수록, 이성적이고 합리적인 판단보다 감성적인 기호와 직감이 중요하게 작용하니 말이다.

## 겹겹이 싸인 괄호들

리스프 코드에 보이는 수많은 괄호가 처음에는 어색하고 괴상해 보이는데, 조금 지나니 적응이 됐다. 특히, 괄호를 닫는 구문은 몇 겹인지 세기도 어려울 정도로 겹치곤 하는데, 이제는 큰 문제로 느껴지지 않는다.

다른 언어에서는 “}”나 “end”등으로 여러 줄에 걸쳐 정리하던 것을 한꺼번에 닫는 것뿐이다. 다른 언어는 줄 바꿈과 띄어쓰기로 특정 블록의 범위를 파악하기 쉬운데, Lisp도 사실 마찬가지였다. 괄호 끝에 커서를 놓으면 어느 괄호와 대응되는 것인지 에디터나 IDE가 잘 표시해주니까 말이다. 사람이 눈으로 확인하기에는 분명 어렵지만, 적절한 띄어쓰기 규칙이 잘 지켜지기 때문에 큰 문제는 아니다.

오히려, 여타 언어에서 여러 줄 번거롭게 이어지는 부분들이, 한줄에 한 부분으로 짧게 축약돼서 더 좋게 느껴지기까지 한다. 게다가 대응되는 괄호 쌍을 다양한 무지개색으로 표시해주는 기능도 있으니, 심지어 아름다워 보이기까지 한다! (나까지 이런 말을 하게 됐다는 걸 자신도 믿을 수 없다)

게다가, Emacs에 있는 paredit 모드 같은 경우, 괄호의 안과 밖으로의 이동이나 범위를 좁히거나 넓히는 기능이 있어서, 일일이 괄호를 옮기는 데에 파격적인 편리함이 있다. 쉽게 얘기하면, 보통의 에디터에서 줄 단위로 소스 코드를 위아래로 이동하는 기능 같은 것인데, 그보다 훨씬 유연하게 움직인다. 아래 EmacsRocks.com의 에피소드 14 동영상을 참고하자.

이런 유용한 기능은 Emacs뿐만 아니라 IntelliJ용 클로저 플러그인인 Cursive에서도 쓸 수 있다. 다른 통합 개발 환경(IDE)이나 에디터도 클로저나 리스프용 플러그인을 쓴다면 이와 비슷하거나 더 우수한 기능이 탑재돼 있을 것이다.

게다가 이런 독특한 모양새가 리스프 계열 언어에서 code-is-data, data-is-code라고 불리는 homoiconicity 성질을 드러내는데, 쉽게 말해서 언어의 의미와 표현이 같은 구조이다. 보통의 프로그래밍 언어는 사람이 읽고 쓰는 소스 코드를 컴파일러나 인터프리터가 최종 코드로 만들기 전에, 전체 구조를 분석해서 AST(Abstract Syntax Tree)를 만들게 되는데, 리스프 계열의 소스 코드는 그 모양새가 언어 텍스트 구조와 일치한다. 다른 언어에서는 연산자의 우선순위에 따라 트리를 구축하는 규칙과 순서가 있어서, 그 의미에 따라 모양새가 달라지기 마련이다.

어려운 얘기지만 어쨌든, 이로 인해 매크로 프로그래밍을 매우 강력하게 활용할 수 있는 바탕이라고 한다. 아직 매크로를 잘 쓰지 못해 더 자신 있게 표현할 수 없어서 아쉽다. 그저 매우 강력한 메타프로그래밍을 할 수 있게 해주는 성질이라고 얘기하고 슬쩍 넘어가 보자.

## 주변에 쓰는 사람이 없다
이 점은 사실 무엇이든 새로운 도구나 언어를 시작해 볼 때의 걸림돌이다. 아무래도 주변에 쓰는 사람이 많아야, 새로운 정보 공유도 쉽고 모르는 부분에 관해 물어볼 사람도 있고, 또 그래야 계속해서 써볼 의욕이 유지되지 않던가? 프로그래밍 언어를 하나 공부한다는 것이, 개인의 의지력만으로는 꾸준히 공부하기 어려운 부분이 있다.

그리고 결국, 프로그래밍 언어를 공부해서 하고자 하는 바는, 어딘가에 써서 활용하겠다는 뜻일 텐데, 큰 회사에 속해서 개발할 때에는, 주변에 함께 개발할 사람을 고려하지 않을 수 없고, 혼자 하는 작은 프로젝트라 하더라도, 그 후에 누군가 그 프로젝트를 이어 받아야 할지도 모르기 때문에, 회사 내의 공용어를 쓸 수밖에 없게 된다. 회사마다 공용어가 최소한 한두 개는 있겠지만, 대개 그 안에 클로저가 포함되지는 않을 것이다.

그래서 빠지기 쉬운 함정이, “주변 사람들을 설득해서 함께 그 새로운 언어를 공부해가며 개발해보자”는 생각을 하게 되는 것인데, 개인적인 경험으로는 권하고 싶은 생각이나 실천 사항은 아니다.
주변 사람과 함께 쓸 언어로 고민하기보다는 개인적으로 공부해보고 실험적으로 써보는 편이 오히려 생산적일 것 같다. 어쩌면, 그런 희소성이 있으므로 역으로 전혀 모르는 다른 클로저 개발자들과의 프로젝트가 생길지도 모른다. 그들의 주변에도 클로저 개발자가 많지 않을 것이고, 다른 클로저 개발자들을 만나고 싶어 할 수도 있으니 말이다. 즉, 주변 사람은 아니겠지만, 함께할 사람은 있을 것이다. 아마도, 제발~!

## 클로저가 매력적인 이유들
사고(思考)의 폭을 넓혀줄 독특한 언어
“리스프는 그것을 마침내 손에 넣게 되었을 때 경험하게 되는 심오한 깨달음을 위해서라도 배울 가치가 있다. 리스프를 이용할 일이 그렇게 많지 않다고 할지라도 그 경험은 그 자체만으로도 당신을 훨씬 훌륭한 프로그래머로 만들어 줄 것이다.” — 에릭 레이먼드

이 글에 앞서 클로저를 시작하는 계기에서 인용했던 문장이다. 언어와 사고(思考)는 상호작용하기 마련이라서, 쓰는 언어에 따라 사고가 확장될 수도 있고 그 반대로 사고가 확장되면 언어의 쓰임새도 확장되기도 한다. 물론 그 반대로 언어와 사고가 서로 제약이 될 수도 있다. 이런 내용을 좀 더 과감하게 표현한 학자는 언어가 사고를 지배한다고까지 말했다.

프로그래밍 언어도 분명 그 언어의 특성과 그 언어 커뮤니티의 스타일에 따라, 프로그래머의 개발 성향과 스타일에 영향을 주고받는다. 아주 빼어난 특성이나 라이브러리등은 결국 다른 프로그래밍 언어에도 전파되곤 하는 한편, 한 언어의 커뮤니티가 모종의 거대한 문화와 관습을 이뤄내는 성향이 있어서 가끔씩은 그 틀에서 벗어나 다른 문화권에서 바라보는 것이 큰 도움이 될 수도 있다. 마치 때로는 멀리 여행을 떠나서 새로운 관점을 배워보는 일이 필요한 것처럼 말이다. 그런 면에서 클로저는 아주 먼 곳에 있는 이색적이고 매력 있는 여행지임이 틀림 없다. 일반적인 프로그래밍 언어와는 사뭇 색다른 개성이 있으니 말이다. 어쩌면 잠깐 왔다가 아주 마음에 들어서 눌러앉고 싶은 그런 여행지일 것이다.

## 동시성(Concurrency) 처리에 유용한 기본 기능들

서버 프로그래밍에 있어 가장 어려운 주제 중에 하나는 아마도 동시성 제어가 아닐까? 여러 스레드(thread)가 같은 메모리 공간의 자원에 동시에 접근하는 경우에 경쟁 조건(race condition)문제가 발생할 수 있으며, 이에 대해 동기화 처리를 잘 해주지 않으면 큰 오류로 이어질 수 있다.

경쟁 조건(race condition)문제를 해결하기 위해 흔히 쓰는 잠금(lock)기반의 동기화 처리는 잘하기 어렵다. 자칫 잘못 처리했더라도 상황에 따라 오류가 매번 드러나는 것은 아니어서 숙련된 개발자가 꼼꼼히 작성하고 나서도 불안감과 찜찜함을 떨치기 어렵다. 어떤 문제가 매번 발생한다면 그 오류는 발견하기도 해결하기도 쉽지만, 어쩌다 발생하는 오류는 발견하기도 처리하기도 어려운 법이다.

그래서, 이 문제를 처리(회피)하기 위한 접근법으로, 얼랭(Erlang)에서 활용하는 액터 모델(Actor Model)처럼 여러 스레드가 아예 메모리를 공유하지 않고 메시지 전달로 처리하는 방법이 있고, 아니면 공유하되 변경하지 않는 방법(immutable)이 있다. 어차피 누구도 바꾸지 않는 자료라면, 여러 스레드에서 잠금 처리 없이 한꺼번에 마구 접근해도 상관이 없다, 언제 어느 시점에 접근하든 늘 같은 값일 테니까. 누구도 변경하지 않으므로 경쟁 조건이 발생하지 않는다.

클로저는 “공유하되 변경하지 않는” 불변(immutable) 자료 구조를 적극적으로 활용한다. 기본 자료구조인 hash-map, list, set 등이 기본 불변(immutable)이다. 예를 들어 리스트에 어떤 아이템을 추가하면, 새로운 리스트가 만들어지고 원래의 리스트는 유지된다. 원래 리스트가 바뀌는 것이 아니므로 기존 리스트를 참조하고 있던 여러 스레드가 동시에 접근해도 괜찮다. 그러면서도, 원래 리스트 대부분을 새 리스트가 공유하기 때문에 메모리나 성능 측면 모두 효율성이 크게 떨어지지 않는다. 이런 불변 자료 구조는 동시성에도 유용하고, 더불어 함수형 프로그래밍(functional programming)에도 적합하다.

그렇다고 현실적으로 모든 자료를 불변으로 처리할 수는 없는 법. 불변 자료 구조와 더불어, optimistic 잠금 처리 기반의 atom, 메시지 전달 비동기식(asynchronous)으로 처리하는 agent, 메모리에서 트랜잭션 처리를 하는 STM(Software Transactional Memory)이 기본 탑재돼 있어서 변이(mutable) 상태에 대해서도 크게 어렵지 않게 스레드-안전(thread-safe)하게 개발할 수 있다.
요약하면, 클로저는 불변 자료 구조와 atom, agent, STM 덕분에 멀티스레드 프로그래밍하기에 편리하고 강력한 언어이다.

## 편리한 REPL 환경
Read-Eval-Print Loop를 줄여서 REPL이라고 한다. 특히 인터프리터 방식의 언어에서 자주 볼 수 있는 REPL은 마치 터미널(shell)에서 명령어를 주고 결과를 받듯이 대화형으로 개발해가는 편리한 환경이다. 루비의 irb처럼 언어 인터프리터와 별도로 REPL을 띄워 사용하기도 하고, Scala나 Node.js처럼 특별한 파라미터 없이 그냥 컴파일러나 인터프리터를 실행하면 기본으로 REPL이 구동되기도 한다.

간단히 말해, 해당 프로그래밍 언어의 한 문장(statement)을 입력하면, 해당 구문이 즉각 실행되어 결과값이 화면에 보이고, 또 다른 문장을 받을 수 있는 환경이 반복되는 식이다. 전통적인 편집-컴파일-실행-디버그(edit-compile-run-debug) 순서로 반복하는 방법에 비해 가볍고 빠르고 편리하게 코드의 결과를 즉각 확인해 가며 개발하기에 좋다.

사실 대부분의 현대 프로그래밍 언어가 REPL을 어떤 식으로든 지원하기에 클로저만의 장점이라고 하기에는 모호한 부분이 있다. 하지만 REPL의 원조는 리스프이고, 또 클로저가 리스프와 한 식구이다 보니, 때때로 “와 이렇게까지 강력하게 REPL로 밀접하게 개발하는 건가?”하는 놀라움이 들 때가 있다.

## (loop (print (eval (read))))
JVM(Java Virtual Machine)에서 돌아가는 언어
자바(JAVA) 프로그래밍 언어에 대한 호불호를 떠나서 JVM 환경이 가진 강점은 인정하지 않을 수 없다. 거의 모든 대중적 플랫폼에서 실행할 수 있고, 필요한 라이브러리라면 거의 전부를 찾을 수 있을 것이며, 가상 기계의 뛰어난 최적화 기능들까지 합세해서 매우 뛰어난 성능까지 무임승차할 수 있다. 게다가 JVM 환경을 목표(target)로 한다는 것은 이미 널리 쓰이고 있는 클라우드 플랫폼에 배포/운영 환경도 그대로 쓸 수 있다는 뜻도 된다. 해당 클라우드 서비스 업체가 클로저를 공식 지원하든 안 하든 상관없이 말이다.

이는 신생의 프로그래밍 언어가 태생적으로 갖게 되는 몇 가지 단점들을 아주 간단히 해결해주게 되는데, 이점이 세상의 꽤 많은 언어가 JVM환경을 기반으로 구현된 이유일 것이다.

클로저도 JVM을 기반으로 밀접하게 상호작용할 수 있어서, 자바 레거시 시스템과 함께 개발한다거나, 아니면 널리 잘 쓰이고 있는 안정적인 자바 라이브러리를 그대로 가져다 쓸 수 있다. 또 그 반대로, 클로저로 개발한 코드를 자바에서 불러 쓰기도 어렵지 않다.
어디에 활용해 볼까?

걸림돌을 뛰어넘고, 여러 매력에도 살짝 설득당했다면, 그다음은 공부해가며 실제로 어딘가에 써야 하겠다.

기존 자바 프로젝트를 다른 사람과 함께 개발하고 있다면, 실험적 기능을 구현하거나 간단히 테스트할 때 클로저 REPL과 유닛테스트 코드를 활용해 보며 쓸 수 있다. 만약 안타깝게도 프로젝트 구성원들이 유닛 테스트에 관심이 별로 없다면, 테스트 코드를 클로저로 작성한다 한들 그 역시 누가 뭐라 하지 않을 것이다. 다행히 테스트 커버리지가 훌륭하게 유지되고 있다면, 결국 정식의 테스트 코드는 자바로 재작성하는 것이 맞겠다. (어느 쪽이 나은 상황인지는 모르겠다.)

아니면 그냥 속 편하게 개인적인 신규 프로젝트를 시작해보자. 누군가를 애써 설득할 필요도 없이 마음껏 클로저로 개발하는 거다. 장난감 프로젝트일지언정, 에릭 레이먼드가 말한 대로 그 경험만으로도 “훌륭한 프로그래머”가 되는 데 가까워지기를 기대하며 말이다.

출처 : https://medium.com/happyprogrammer-in-jeju/%ED%81%B4%EB%A1%9C%EC%A0%80-clojure-%EC%97%90-%EB%B9%A0%EC%A0%B8%EB%93%A4%EA%B8%B0-e907da3f7fc

# Clojure 언어의 특징

프로그램 개발과 유지/보수 시간 단축 --> 프로그래밍 생산성의 증가

프로그램 실행 속도보다 프로그램 개발 속도가 더 중요하다.

## 1. 클로저 코드는 짧고 간결하다.

구현하고자 하는 로직에만 집중할 수 있다.

프로그램의 이해/유지/보수에 유리하다.

Java: 441 lines of code across 7 files. Clojure: 58 lines of code in 1 file.

클로저 디자인 패턴

## 2. 클로저는 다른 동적 언어들에 비해 속도가 월등하게 빠르다.
https://benchmarksgame.alioth.debian.org/u64q/clojure.html

## 3. 클로저는 Lisp 계열 언어다.
프로그래밍 언어의 역사에서 Fortran 다음으로 등장한 오래된 언어임에도 여전히 많은 Lisp 계열 언어들이 만들어지고 있다. <-- 간결하면서도 표현력 높은 코드를 만들 수 있다.

Lisp programming language family

List of Common Lisp implementations

List of Scheme implementations

강력한 매크로 프로그래밍이 가능하다. 매크로를 이용하면 코드를 더 짧게 표현할 수 있다.

## 4. 클로저에서는 자바의 라이브러리를 그대로 불러 쓸 수 있다.
클로저스크립트에서는 자바스크립트의 라이브러리를 그대로 불러 쓸 수 있다.

## 5. 클로저는 함수형 언어다.
Rich Hickey는 "클로저는 80% 함수형 언어다."

Haskell처럼 어렵지는 않다.

함수형 언어가 주목받는 이유: immutability(변수의 내용을 한 번 초기화한 이후에는 변경 불가능)의 도입으로 상태(state)를 최대한 제거함으로써 프로그램의 복잡성을 최대한 줄여준다.

고르디우스의 매듭(Gordian Knot)

OOP:  code + data = class: data를 숨긴다

FP:   code와 data의 분리: data를 노출시킨다

객체지향언어에서의 상태 관리
oop

Clojure에서의 상태 관리
fp

## 6. 클로저는 동적 언어(Dynamc Language)이다
"It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures."

— Alan Perlis
Ruby나 Python같은 다른 동적 언어들: 클래스(User-defined Type) 기반의 객체지향 언어

Clojure는 지원하는 데이터형이 많지 않다. (총 15개)

장점: 함수의 합성이 용이

단점: 세밀한 type checking을 하기 어렵다.

## 6.1. Ruby의 예
```
# box.rb
class Box
   # constructor method
   def initialize(w,h)
      @width, @height = w, h
   end

   # accessor methods
   def printWidth
      @with
   end

   def printHeight
      @height
   end
end
```

## create an object
```
box = Box.new(10, 20)
```

## use accessor methods
```
x = box.printWidth()
y = box.printHeight()

puts "Width of the box is : #{x}"
puts "Height of the box is : #{y}"
$ ruby box.rb
box.rb:12: warning: instance variable @with not initialized
Width of the box is :
Height of the box is : 20
6.2. Clojure의 예
(def box {:width 10
          :height 20})

(defn print-box [box]
  (println "Width of the box is" (:with box))
  (println "Height of the box is" (:height box)))

(print-box box)
; => Width of the box is nil
;    Height of the box is 20
Last updated 2016-11-12 12:30:21 KST
```
출처 : https://medium.com/happyprogrammer-in-jeju/%ED%81%B4%EB%A1%9C%EC%A0%80-clojure-%EC%97%90-%EB%B9%A0%EC%A0%B8%EB%93%A4%EA%B8%B0-e907da3f7fc

# 클로저(Clojure)란?
** 해당 포스트는 Brian Will Youtube Channel의 Clojure 강의를 번역한 것입니다 (하단 링크 첨부). **

프로그래밍 언어 클로저(Clojure)는 2007년, Rich Hickey에 의해 만들어졌다. 클로저의 가장 첫 번째로 오는 특징은 바로 Lisp의 분화라는 것이다. Lisp는 1950년대에 John McCarthy에 의해 만들어졌으며, 현대 프로그래밍에서 자주 언급이 되는 일급 객체와 함수, 가비지 컬렉션 등의 개념의 근간의 역할을 하고 있다. Lisp 그 자체는 초기에는 많이 그리고 오래 사용되지는 않았지만 많은 모방꾼(imitators)들이 존재했다. 

이런 모방꾼들을 macro를 Lisp 내로 들여왔는데 macro란 source code를 input으로 받고 output을 source code로 내뱉는 것이라고 한다 (macro는 나중에 다룬다). Non-Lisp 언어들도 macro의 역할을 하는 것들이 종종 존재하지만 그것이 Lisp에 존재하는 macro와 비견할 수 없다고 한다. C언어에도 ‘Preprocessor’가 존재하지만 실상 사용하기에 syntax가 너무 사용하기 힘들고 복잡해서 잘 사용하지 않는다 한다. 

하지만 Lisp의 Syntax는 매우 쉬워서 이 macro 작성이 수월하다.

하지만 비단 위와 같은 이유로 Clojure가 개쩐다고 말하기는 부족하다.

클로저의 우수성은 Functional programming(이하 FP)에 대한 접근법에 있다. 많이들 헷갈려하고, 특히 내 자신이 아직 잘 개념이 확립이 안되었기 때문에 이 글을 통해서 한 번 다시 정리하고자 한다.

## 함수형 프로그래밍이란?
함수형 프로그래밍은 우리가 흔히들 알고 있는 명령형(Imperative) 프로그래밍과 대조를 이루는 프로그래밍 형태이다. 

이 둘의 핵심적인 차이는 바로 변할 수 있는 변수, 즉 mutable state를 어떻게 다루느냐이다. 만약에 변수에 새로운 값이 대입될 수 있다면, object field가 변한다면, array의 값들이 변한다면 mutable state라고 부를 수 있다. 명령형 프로그래밍에서는 언제든지 우리가 변수에 원하는 값을 대입하여 변경할 수 있지만 함수형 프로그래밍에서는 최대한 이 변하는 상황을 모면하고자 한다. 그 이유는 함수에서 mutable state를 사용하지 않는다면 참조투명성(referentially transparent)을 갖기 때문이다. 

참조 투명성이라는 뜻은 같은 input에는 항상 같은 output을 내놓는다는 뜻이다. 이는 다른 말로 pure function이라고도 부른다. Impure function은 같은 set의 argument가 제시된다고 해도 다른 return value를 내뱉을 수 있는데 function이 외부의 mutable state (ex. global variable) 에 의존할 수 있기 때문이다. 또한 역으로 function이 외부의 mutable state를 변화시킬 수도 있다.

이것이 함수형 프로그래밍의 골자이며 mutable state가 존재하지 않음으로써 비로소 함수가 truly modular(독립적인?) 하게 되는데, 왜냐면 하나의 함수를 관리함에 있어 다른 함수의 눈치를 안보고 독자적으로 활동할 수 있기 때문이다.

그런데 이런 의문이 들 수가 있다.

아니, 물론 부수효과가 존재한다고 해도 Mutable state가 편하지 않나?

이것은 우리가 FP로 새로운 변수를 만들 수 있음을 지각하지 못할 때 나올 수 있는 생각이다. 함수형 프로그래밍에서의 변수에 새로운 값을 할당하는 일은 ‘기존 변수’에 몇가지 변형을 가한 ‘새로운 Copy’를 만들어내는 것이다. 즉 기존 변수를 조작하는 대신에 (기존 변수의 값 + modification)의 새로운 변수를 만들어낸다고 보면 된다.

예를 들어,

[1 2 3] -> [1 7 4] (a new, seperate list)
기존의 [1 2 3]을 [1 7 4]로 바꾸려면 어떻게 하면 되겠는가? 기존의 imperative programming이라면 두 번째 숫자를 2에서 7로 바꾸면 된다. 하지만 FP에선 2를 7로 바꾼 전혀 새로운 list를 만들게 되어 mutable state가 발생할 여지를 없애버리게 된다.

하지만 당연히 가져야만 하는 의문은… 그럼 비용이 너무 과하지 않나용??

만약 [1 2 3]을 [1 2 4]/[1 2 5]/[1 2 6] 이런식으로 변형을 여러 번 준다고 하면 중복 데이터가 너무 많아지게 되지 않는가?

이것을 해결하기 위하여 Persistent Collection(이하 PC)이 등장하게 된다. PC는 immutable을 지원하나 Copy를 쉽게 만들어주는 역할을 하게 된다. 간단하게 말하자면, PC는 기존의 변수와 새로운 변수가 공유하고 있는 값들은 Memory에서 Share하게 된다. 예를 들어

[1 2 3 4 5 6 7 8 9]
--> [1 2 3 4 5 6 7 8 9 "HI"]
위와 같이 기존 list를 새로운 list로 바꾸게 될 때 바뀌지 않은 부분의 데이터는 공유하게 되고 새로운 것만 갖는 변수의 Copy를 갖기 때문에 Memory에 부하를 주지 않게 된다. Persistent Data structure에 대해서 좀 더 자세히 이해하고 싶은 사람들은 다음 link를 읽어본다면 꽤 괜찮은 답을 얻을 수 있을 것이다.

 https://hackernoon.com/how-immutable-data-structures-e-g-immutable-js-are-optimized-using-structural-sharing-e4424a866d56

하지만 이것은 너무 이상적인 예시였다.
사실 현실에서는 mutable을 극복하고 피하는 것이 쉽지많은 않다. I/O의 세계를 살펴보기만 해도 (Files, network resources, user interactions, etc) 수많은 mutable state들이 존재한다. 파일을 읽고 그것을 화면이 띄우는 활동도 모두 mutable state를 다루는 것이다. Haskell이나 Scala 같은 프로그램과 같은 함수형 프로그래밍 언어에서는 악명높은 ‘monad’ 데이터 타입을 사용해서 이 문제를 극복하고자 한다.

## 하지만 Clojure에는 이에 대한 해결책이 딱히 없다. 

그리고 있어야 할 필요가 크게 없는 것이 함수형 프로그래밍은 mutable state를 제한하는 것이지 없애려고 혈안이 되어 있는 프로그래밍이 아니다. 필요할 때는 그것을 사용할 때가 존재하기는 한다. Clojure는 순전히 프로그래머에게 pure code의 비율이 impure보다 많을 것을 추천할 뿐이다. 따라서 Clojure에서도 일정 량의 mutable data가 존재하기는 하지만, 그의 존재는 multiple thread에서 발생하는 실행이 매우 까다로워지는 것이다. 각각의 thread execution은 서로를 망칠 수 있는데 그 이유는 하나의 thread의 행동이 다른 thread의 행동이 예상하는 방향으로 진행되지 않을 수 있기 때문이다.

이것을 해결하기 위해 Reference type을 내놓는데 이는 추후에 설명하도록 한다.

## Java의 연동성
Clojure는 기본적으로 Compile시 Java bytecode로 진행하며 JVM상에서 구동되고 Clojure data type이 Java class에 의해 정의된다. Clojure는 Java와의 연동성이 매우 좋아 Java library로 일하는 경우가 많다.

No (encapsulation, inheritance) but yes polymorphism
Clojure 개발자인 Rich Hickey는 OOP를 거의 경멸 수준으로 바라봤기 때문에 Java와 Clojure의 깊은 관계에서도 OOP 특성인 encapsulation과 inheritance를 데이터 타입에서 제외하였다. 하지만 그 중에서 polymorphism은 좋아했기 때문에 추가했다고 한다. 이로 인해서 함수를 정의할 때 argument arity가 달라짐에 따라 행동을 다르게 할 수 있게 만들 수 있는 것이다.

출처 : https://hoonst.github.io/clojure/2019/08/19/clojure-what-so-good-about-it/